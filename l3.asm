;===================================;
;                                   ;
; Поиск наибольшего общего делителя ;
; для (k > 0) и (k < 256);
;                                   ;
;===================================;


.model tiny


;========================== STACK ====================================
s_s segment stack 'stack'
        
        db    0ffh dup(?)         ; Резервирование 256 байт
    
s_s ends

;========================== DATA  ====================================
d_s segment memory 'data'
        
        a      db    4            ; Первое число
        b      db    8            ; Второе число
        gcd    db    ?            ; Наибольший общий делитель

d_s ends

;========================== CODE  ====================================
c_s segment public 'code'
assume cs:c_s, ss:s_s, ds:d_s, es:d_s
start:

    ; Подготовка регистра сегмента данных
    mov		ax, d_s
    mov		ds, ax
    
    ; Определение минимального из 2 чисел
	xor		ch, ch
	mov		cl, a		; По умолчанию первое число минимальное
    cmp		cl, b
	ja		MIN_2
	jmp		short FIND_GCD
	; Если первое окажется больше, второе число минимальное
MIN_2:
	mov		cl, b

	; Поиск наибольшего общего делителя
	; cx будет содержать текущий НОД
FIND_GCD:
	; Проверка делимости первого на текущий НОД
	mov		al, a
	xor		ah, ah
	div		cl
	; Если первое не делится, переходм к следующему НОДу
	cmp     ah, 0
	jne     NEXT_GCD
	; Проверка делимости второго на текущий НОД
	mov		al, b
	div		cl
	; Если второе число тоже делится на текущий НОД, поиск закончен
	cmp		ah, 0
	je		GCD_FOUND
NEXT_GCD:
	loop	FIND_GCD
	
GCD_FOUND:
	; Сохранение найденого НОДа
	mov		gcd, cl
	
	; Подсчёт количества 1 в НОДе
	xor		dl, dl		; Количество 1
	mov		al, cl		; Найденный НОД
	mov		cx, 8		; Количество просматриваемых битов
SUM_BIT:
	ror		al, 1
	; Увеличиваем счётчик единиц только, если текущий бит 1
	jnc		NEXT_BIT
	inc		dl
NEXT_BIT:
	loop	SUM_BIT
    
    ; Завершение программы
    mov    ax, 4c00h
    int    21h
    
c_s ends
end start
