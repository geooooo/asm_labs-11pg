; Задача N8
; Ввод массива целых чисел
; И поиск первого положительного элемента
; Индексы массива считаются с 0003h
; Допустимые к вводу целые числа -9..9

S_S segment stack
			db	100 dup(?)			; Резервируем в стеке 100 байт
S_S ends


D_S segment
	a    			db	7 dup(1)						; Вводимый массив целых чисел
	msg_not_found	db	0dh,0ah,'Number not found !$'	; Сообщение, выводимое если не найдено число >= 0
	msg_found 		db  0dh,0ah,'Array[i] = $'			; Сообщение, выводимое если число найдено
D_S ends


C_S segment
assume ss:S_S, cs:C_S, ds:D_S, es:D_S
start:

	; Подготовка регистра сегмента данных
	mov		ax, D_S
	mov		ds, ax
	
	; Очистка экрана
	mov		ax, 0003h
	int		10h
	
	; Ввод массива
	mov		cx, 7		; Повторяем цикл loop 7 раз, т.к. в массиве 7 чисел
	mov		si, 0		; si - индекс элемента массива, начиная с нуля
INPUT_A:
	; Считывание символа с клавиатуры, al - код введёного символа
	mov		ah, 01h
	int		21h
	; Проверка введённого символа
	; Если ввели пробел, то перейти к вводу следующего символа
	cmp		al, ' '
	je		INPUT_A
	; Если ввели минус '-', число отрицательно
	cmp		al, '-'
	jne		CMPN1		; Если был введён не минус, переходим к следующим проверкам
	mov		a[si], -1	; Иначе, делаем элемент массива отрицательным
	jmp		INPUT_A		; Переходим к вводу следующего сивола
CMPN1:
	; Проверяем, является ли символ числом, если нет, то выходим из программы
	cmp		al, '0'
	jb		EXIT		
	cmp		al, '9'
	jg		EXIT
	; В любом другом случае было введено число
	sub		al, '0'		; Преобразуем символ в число: al - код '0' = число
	; Запись числа в массив
	mov		bl, al
	mov		al, a[si]
	imul	bl
	mov		a[si], al	; a[si] = a[si] * bl (a[si] может быть = -1, если был введён '-', изначально = 1)
	inc		si			; Переходим к следующему числу
	loop	INPUT_A
	
	; Поиск первого положительного элемента массива
	mov		si, 0		; si - индекс элемента массива, начиная с нуля
	mov		cx, 7		; Повторяем цикл loop 7 раз, т.к. в массиве 7 чисел
FIND_POSITIV:
	; Проверка очередного числа массива на >= 0
	cmp		a[si], 0
	jge		FIND_POSITIV_OK		; Выходим из цикла, если нашли положительное число
	inc		si					; Переходим к следующему элементу
	loop	FIND_POSITIV
	
	; Сюда попадём, если не нашли подходящее число
	; Выведем сообщение о том, что число не найдено и завершим программу
	mov		ah, 09h						; Функция вывода строки
	mov		dx, offset msg_not_found	; Смещение строки-сообщения
	int		21h
	jmp		EXIT
	
FIND_POSITIV_OK:
	; Сюда переходим, если нашли положительное число
	; si - индекс найденного числа, a[si] - число
	mov		cl, a[si]					; Сохраняем найденное число
	add		cl, '0'						; Преобразуем число в символ: сl + код '0' = число в виде символа
	add		si, '0'						; Преобразуем индекс в символ: si + код '0' = индекс в виде символа
	; Записываем индекс найденого элемента в строку msg_found вместо буквы i 'Array[вместо i - индекс] = '
	mov		ax, D_S
	mov		es, ax
	mov		ax, si
	mov		di, offset msg_found + 8
	stosb								; Команда записывает байт из al по адресу es:[di]
	; Выводим сообщение об успехе и индекс элемента
	mov		ah, 09h						; Функция вывода строки
	mov		dx, offset msg_found		; Смещение строки-сообщения
	int		21h
	; Вывод числа
	mov		ah, 02h						; Функция вывода символа
	mov		dl, cl						; dl - символ для вывода, т.е. найденное число
	int		21h
	
EXIT:
	; Завершение программы
	mov		ax, 4c00h
	int		21h
	
C_S ends
end start