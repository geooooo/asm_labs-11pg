;============================;
;							 ;
;	Лабораторная №4			 ;
;	Обработка массивов		 ;
;							 ;
;============================;


.model	tiny


;================ DATA ==================;
d_s segment 

	arr		dw		18 dup(?)		; Исходный массив
	min		dw		0				; Минимальный элемент массива
	max		dw		0			    ; Максимальный элемент массива
	
d_s ends


;================ STACK ==================;
s_s segment stack
	
			db		0ffh dup(?)		; Резервирование 256 байт
	
s_s ends


;================ CODE ==================;
c_s segment
assume cs:c_s, ss:s_s, ds:d_s, es:d_s
start:

	; Инициализация сегмента данных
	mov		ax, d_s
	mov		ds, ax
	
	; Вычисление чисел Фибоначчи
	; Первые 2-ое чисел 1
	mov		[arr], 0
	mov		[arr+2], 1
	; Вычисление остальных чисел 
	; bx - очередное число Фибоначчи
	; si - индекс массива
	; cx - количество вычисляемых чисел
	mov		cx, 16
	xor		si, si
NEXT_FIB:
	; Получение и запись нового числа
	xor		bx, bx
	add		bx, arr[si]
	add		bx, arr[si+2]
	mov		arr[si+4], bx
	; Переход к следующему числу
	add		si, 2
	loop	NEXT_FIB
	
	; Поиск наименьшего нечётного элемента 2-ой строки массива (3х6
	; Нумерация строк и столбцов с 0
	xor		dx, dx		; Искомый минимум
	dec		dx
	mov		cx, 6		; Просмотр всей строки
	mov		bx, 12  	; 2-ая строка
	xor		si, si  	; Начиная с 1-ого элемента
FIND_MIN:
	; Проверка элемента на нечётность по последнему биту числа
	test	arr[bx][si], 1
	jz		FIND_MIN_NEXT
	; Если последний бит оказался 1, сравниваем его с минимумом
	cmp		arr[bx][si], dx
	jae		FIND_MIN_NEXT
	; Если очередной элемент меньше записываем новый минимум
	mov		dx, arr[bx][si]
FIND_MIN_NEXT:
	; Переход к следующему элементу
	add		si, 2
	loop	FIND_MIN
	mov		min, dx

	; Поиск наибольшего чётного элемента 4-ого столбца
	; Нумерация строк и столбцов с 0
	xor		dx, dx		; Искомый максимум
	mov		cx, 3		; Просмотр всего столбца
	xor		bx, bx		; Просмотр всех строк
	mov		si, 6		; Поиск в 4-ом столбце
FIND_MAX:
	; Проверка элемента на чётность по последнему биту числа
	test	arr[bx][si], 1
	jnz		FIND_MAX_NEXT
	; Если последний бит оказался 0, сравниваем его с максимумом
	cmp		arr[bx][si], dx
	jbe		FIND_MAX_NEXT
	; Если очередной элемент больше записываем новый максимум
	mov		dx, arr[bx][si]
FIND_MAX_NEXT:
	; Переход к следующей строке
	add		bx, 12
	loop	FIND_MAX
	mov		max, dx
	
	; Завершение программы
	mov		ax, 4c00h
	int		21h

c_s ends
end start